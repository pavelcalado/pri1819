\documentclass[12pt]{article}

\usepackage{prilab}


\begin{document}

\maketitle{Lab 06: XML, XPath and XQuery}

In each of the proposed exercises, you should take as input the XML document named {\it AirFlightsData.xml}, available from the course webpage, which represents information about flights, airports, passengers and reservations. The XML excerpt shown below illustrates the contents of the full document.

\begin{verbatim}
<doc>
  <Airport airId="LHR">
        <name>London Heathrow</name>
        <tax>100</tax>
  </Airport>
  <Flight flightId="LX123">
        <seats>100</seats>
        <date>2008-12-24</date>
        <departure>08:00:00</departure>
        <arrival>10:00:00</arrival>
        <source>LHR</source>
        <destination>ZRH</destination>
  </Flight>
  <Passenger>
        <name>Santa Claus</name>
        <passportnumber>000114</passportnumber>
        <address>Somewhere</address>        
  </Passenger>
  <Reservation>
        <date>2008-12-24</date>
        <flightRef>LX140</flightRef>
        <passRef>000112</passRef>
  </Reservation>
</doc>

\end{verbatim}

\section{}

The Python standard library contains simple mechanisms for processing semi-structured data on the JSON format. In brief, the Python {\tt json} library can parse JSON from strings or files (i.e., parsing JSON into a Python dictionary or list), and it can also convert Python dictionaries or lists into JSON strings.

\begin{verbatim}
import json
json_string = '{"first_name": "Bruno", "last_name":"Martns"}'
parsed_json = json.loads(json_string)
print(parsed_json["first_name"])
\end{verbatim}

The Python standard library also contains mechanisms for processing XML documents and for evaluating XPath expressions (e.g., {\tt ElementTree}, as shown in the example below). %Under Python 2.6 the compliance with the XPath standard is relatively weak, but these functionalities have been inproved in Python 2.7.

\begin{verbatim}
import xml.etree.ElementTree as ET
root = ET.parse("filename.xml")
for elem in root.findall(".//child-element/grandchild-element/*"):
    if elem.attrib.get("name") == "foo": print ( elem.text )
\end{verbatim}

External libraries such as libxml2\footnote{\url{http://xmlsoft.org/python.html}} can also be used, and these often have advantages in terms of processing speed, and in terms of compliance with the XPath 2.0 standard.

\begin{verbatim}
import libxml2
doc = libxml2.parseFile("filename.xml")
for res in doc.xpathEval("//*"):
  print res.name
  print res.content
doc.freeDoc()
\end{verbatim}

There are also several alternatives for evaluating XQuery expressions within Python programs. Full-featured XML databases such as Zorba or Oracle's Berkeley DB XML have bindings for the Python language, and simple native libraries such as python-simplexquery\footnote{\url{https://pypi.python.org/pypi/python-simplexquery}} can also be used.

\begin{verbatim}
import simplexquery as sxq
res = sxq.execute("doc('filename.xml')//*")
print res
\end{verbatim}

You can use the aforementioned libraries to test the XPath/XQuery expresions from the following exercises.

\section{}

Explain, in your own words, the logic underlying the following XPath expressions. Also use Python to execute each XPath expression over the context of the XML document indicated at the beginning.

\begin{enumerate}
\item {\tt //date }
\item {\tt //Flight[date="2008-12-24"] }
\item {\tt //Airport[name="Zurich"]/following-sibling::Airport }
\item {\tt /doc/Flight/*[position()<3] }
\end{enumerate}

\section{Pen and Paper Exercises}

\subsection{XPath}

Write XPath expressions that, using the XML document from the beginning, support the following information needs:

\begin{itemize}
\item	Return the name for all airports.

\item	Return the destination of the 3rd flight on the XML document, if one such flight exists.

\item	Return the departure date for all flights having {\it ZRH} or {\it PRG} as the destination.

\item	List all flights from {\it London Heathrow} (i.e., perform a join between the airport and the corresponding flights).

\item	Return all flights for which passenger {\it Santa Claus} has a reservation.

\item	Return the number of flights having more than 90 seats.
\end{itemize}

\subsection{Simple XQuery Expressions}

Considering the XML document from the begining, write XQuery FLWOR expressions for each of the following information needs. 

\begin{itemize}
\item List all flights to the airport named {\it Rome Fiumicino}.
\item List all flights to {\it Rome} (i.e., to the airport containing {\it Rome} in its name) sorted by the corresponding departure time.
\item List the name for all passengers of flights with destination to {\it Zurich}.
\item List all airports that have {\it London} as part of their name.
\end{itemize}

Could you also express these three queries with XPath expressions? Justify.

\subsection{Advanced XQuery Expressions}

Write XQuery FLWOR expressions for each of the following information needs. The XQuery expressions should produce, as result, well-formed XML documents.

\begin{itemize}
\item Return the list of direct flights with date {\it 2008-12-24} that have {\it North Pole} as the name for the airport of origin. 
\item Return the 5 airports with more traffic in {\it 2008-12-24}, with basis on the number of departures and arrivals.
\item Consider all the flights for {\it 2008-12-24}. For each airport listed in the XML document, compute the number of flights having that airport as the destination.
\item For each flight, present the list of corresponding passengers. Flights with an empty list of passenger should also be presented in the results. 
\item Write an XQuery expression for returning all possible combinations of flights from {\it North Pole} to {\it South Pole}, in the date {\it 2008-12-24}, with two or more connecting flights.
\item Return the list of flights described in the XML document, removing from each flight the XML element that encodes the number of available seats. 
\end{itemize}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
